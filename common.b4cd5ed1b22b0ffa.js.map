{"version":3,"file":"common.b4cd5ed1b22b0ffa.js","mappings":"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","names":["EventsApiService","constructor","this","inject","Firestore","collection","firestore","Collection","getFilteredEvents","eventQuery","query","eventsCollection","where","orderBy","from","getDocs","pipe","switchMap","data","schedules","docs","map","doc","event","scheduleCollection","uid","scheduleQuery","response","schedule","start_date","end_date","is_active","forkJoin","datas","flat","getEvents","usersQuery","addEvent","hasParameter","created_on","Timestamp","updated_on","addDoc","start_time","toDate","getHours","getMinutes","end_time","getDateList","days","currentDate","setHours","addSchedules","id","updateEvent","throwError","Error","eventUID","batch","writeBatch","set","commit","ref","getDoc","exists","updateDoc","setDoc","removeEvent","list","current","getTime","toMillis","includes","getDay","push","Date","setDate","getDate","object","key","undefined","factory","colors","red","primary","secondary","blue","yellow","UserPipe","UserApiService","transform","value","console","log","userApiService","getUser","of","pure","TeacherApiService","getTeachers","teacherQuery","teacherCollection","teacherData","teacherObject","reduce","prev","user_uids","getUsersInList","users","user","phone","email","first_name","middle_name","last_name","avatar_url","avatar_urls","styles","level","getTeacher","teacher","addTeacher","updateUser","is_teacher","removeTeacher","TeacherService","getList","teacherApiService","getUsers","getUsersNotTeachers"],"sourceRoot":"webpack:///","sources":["./src/app/backend/services/events-api.service.ts","./src/app/calendar/utils/colors.ts","./src/app/shared/pipes/user.pipe.ts","./src/app/backend/services/teacher-api.service.ts","./src/app/teacher/services/teacher.service.ts"],"sourcesContent":["import { Injectable, inject } from '@angular/core';\nimport { Firestore, Timestamp, addDoc, collection, doc, getDoc, getDocs, orderBy, query, setDoc, updateDoc, where, writeBatch } from '@angular/fire/firestore';\nimport { Collection } from '../model/collections';\nimport { Observable, forkJoin, from, map, switchMap, throwError } from 'rxjs';\nimport { ICalendarEvent, IEventSchedule } from '../model/event';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class EventsApiService {\n  private firestore: Firestore = inject(Firestore);\n  private eventsCollection = collection(this.firestore, Collection.EVENTS);\n\n  getFilteredEvents(): Observable<ICalendarEvent[]> {\n    // create an index in a firebase to sort and order\n    const eventQuery = query(this.eventsCollection, where('is_active', '==', true), orderBy('start_date'));\n    return from(getDocs(eventQuery)).pipe(\n      switchMap(data => {\n        const events = data.docs.map(doc => doc.data() as ICalendarEvent);\n        const schedules = events.map(event => {\n          const scheduleCollection = collection(this.firestore, Collection.EVENTS, event.uid, Collection.EVENT_SCHEDULES);\n          const scheduleQuery = query(scheduleCollection);\n          return from(getDocs(scheduleQuery)).pipe(\n            map(\n              response => response.docs.map(doc => doc.data() as IEventSchedule).map(schedule => ({\n                ...event,\n                start_date: schedule.start_date,\n                end_date: schedule.end_date,\n                is_active: schedule.is_active,\n              } as ICalendarEvent))\n            ),\n          )\n        });\n        return forkJoin(schedules).pipe(\n          map(datas => datas.flat()),\n        );\n      }),\n    )\n  }\n\n  getEvents(): Observable<ICalendarEvent[]> {\n    const usersQuery = query(this.eventsCollection, orderBy('created_on', 'desc'));\n    return from(getDocs(usersQuery)).pipe(\n      map(data => data.docs.map(doc => doc.data() as ICalendarEvent)),\n    )\n  }\n\n  addEvent(event: Exclude<ICalendarEvent, 'uid' | 'created_on' | 'updated_on'>): Observable<string> {\n    if (!event) {\n      return throwError(() => new Error('Event is missing'));\n    }\n    if (\n      !this.hasParameter(event, 'start_date') ||\n      !this.hasParameter(event, 'end_date') ||\n      !this.hasParameter(event, 'days')\n    ) {\n      return throwError(() => new Error('Parameter is missing'));\n    }\n    event.created_on = Timestamp.now();\n    event.updated_on = Timestamp.now();\n    event.is_active = true;\n    return from(addDoc(this.eventsCollection, event)).pipe(\n      switchMap(doc => {\n        const start_time = [event.start_date.toDate().getHours(), event.start_date.toDate().getMinutes()];\n        const end_time = [event.end_date.toDate().getHours(), event.end_date.toDate().getMinutes()];\n        const schedules: Partial<IEventSchedule>[] = this.getDateList(event.start_date, event.end_date, event.days).map(currentDate => {\n          return {\n            is_active: true,\n            start_date: Timestamp.fromMillis(currentDate.setHours(start_time[0], start_time[1])),\n            end_date: Timestamp.fromMillis(currentDate.setHours(end_time[0], end_time[1])),\n          }\n        });\n        return forkJoin([\n          this.addSchedules(doc.id, schedules),\n          this.updateEvent({ uid: doc.id }),\n        ]).pipe(\n          map(() => doc.id),\n        )\n      })\n    );\n  }\n\n  addSchedules(eventUID: string, schedules: Partial<IEventSchedule>[]): Observable<void> {\n    const batch = writeBatch(this.firestore);\n    const scheduleCollection = collection(this.firestore, Collection.EVENTS, eventUID, Collection.EVENT_SCHEDULES);\n    schedules.map(schedule => {\n      batch.set(doc(scheduleCollection), schedule);\n    });\n    return from(batch.commit());\n  }\n\n  updateEvent(event: Partial<ICalendarEvent>): Observable<void> {\n    if (!event.uid) {\n      return throwError(() => new Error('ID is missing'));\n    }\n    const ref = doc(this.eventsCollection, event.uid);\n    return from(getDoc(ref)).pipe(\n      switchMap(doc => {\n        event.updated_on = Timestamp.now();\n        if (doc.exists()) {\n          return from(updateDoc(ref, event))\n        }\n        event.created_on = Timestamp.now();\n        return from(setDoc(ref, event))\n      }),\n    )\n  }\n\n  removeEvent(event: Partial<ICalendarEvent>): Observable<void> {\n    const ref = doc(this.eventsCollection, event.uid);\n    event.updated_on = Timestamp.now();\n    return from(updateDoc(ref, {\n      is_active: false,\n      updated_on: event.updated_on,\n    }));\n  }\n\n  private getDateList(start_date: Timestamp, end_date: Timestamp, days: number[]): Date[] {\n    if (!start_date || !end_date) {\n      return [];\n    }\n    const list: Date[] = [];\n    let current = start_date.toDate();\n    while (current.getTime() <= end_date.toMillis()) {\n      if (days.includes(current.getDay())) {\n        list.push(new Date(current));\n      }\n      current.setDate(current.getDate() + 1);\n    }\n    return list;\n  }\n\n  private hasParameter<T>(object: T, key: keyof T): boolean {\n    return object[key] !== null || object[key] !== undefined;\n  }\n}\n","export const colors = {\r\n  red: {\r\n    primary: '#ad2121',\r\n    secondary: '#FAE3E3',\r\n  },\r\n  blue: {\r\n    primary: '#1e90ff',\r\n    secondary: '#D1E8FF',\r\n  },\r\n  yellow: {\r\n    primary: '#e3bc08',\r\n    secondary: '#FDF1BA',\r\n  },\r\n}\r\n","import { Pipe, PipeTransform, inject } from '@angular/core';\nimport { Observable, of } from 'rxjs';\nimport { ProfileDTO } from 'src/app/backend/model/profile';\nimport { UserApiService } from 'src/app/backend/services/user-api.service';\n\n@Pipe({\n  name: 'user',\n})\nexport class UserPipe implements PipeTransform {\n  private userApiService = inject(UserApiService);\n\n  transform(value: string): Observable<ProfileDTO | null> {\n    if (!value) {\n      return of(null);\n    }\n    console.log(value)\n    return this.userApiService.getUser(value);\n  }\n\n}\n","import { Injectable, inject } from '@angular/core';\nimport { Firestore, Timestamp, collection, doc, getDoc, getDocs, query, setDoc, updateDoc, where } from '@angular/fire/firestore';\nimport { Observable, from, map, switchMap } from 'rxjs';\nimport { Teacher, TeacherDTO } from '../model/teacher';\nimport { Collection } from '../model/collections';\nimport { UserApiService } from './user-api.service';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class TeacherApiService {\n  private firestore: Firestore = inject(Firestore);\n  private teacherCollection = collection(this.firestore, Collection.TEACHER);\n  private userApiService = inject(UserApiService);\n\n  getTeachers(): Observable<TeacherDTO[]> {\n    const teacherQuery = query(this.teacherCollection, where('is_active', '==', true));\n    const teacherSnapshot = from(getDocs(teacherQuery));\n    return teacherSnapshot.pipe(\n      switchMap(data => {\n        const teacherData = data.docs.map(doc => doc.data() as Teacher);\n        const teacherObject: {[key: string]: Teacher} = teacherData.reduce((prev, current) => ({\n          ...prev,\n          [current.uid]: current,\n        }), {});\n        const user_uids = teacherData.map(doc => doc.uid);\n        return this.userApiService.getUsersInList(user_uids).pipe(\n          map(users => {\n            return users.map(user => {\n              const consolidated: TeacherDTO = {\n                uid: teacherObject[user.uid].uid,\n                phone: user.phone,\n                email: user.email,\n                first_name: user.first_name,\n                middle_name: user.middle_name,\n                last_name: user.last_name,\n                avatar_url: user.avatar_urls ? user.avatar_urls[0] : '',\n                start_date: teacherObject[user.uid].start_date,\n                styles: teacherObject[user.uid].styles,\n                level: teacherObject[user.uid].level,\n              };\n              return consolidated;\n            })\n          })\n        )\n      })\n    )\n  }\n\n  getTeacher(uid: string): Observable<TeacherDTO> {\n    const ref = doc(this.teacherCollection, uid);\n    return from(getDoc(ref)).pipe(\n      map(data => data.data() as Teacher),\n      switchMap(teacher => {\n        return this.userApiService.getUser(teacher.uid).pipe(\n          map(user => ({\n            uid: teacher.uid,\n            phone: user.phone,\n            email: user.email,\n            first_name: user.first_name,\n            middle_name: user.middle_name,\n            last_name: user.last_name,\n            avatar_url: user.avatar_urls[0],\n            start_date: teacher.start_date,\n            styles: teacher.styles,\n            level: teacher.level,\n          }))\n        )\n      })\n    )\n  }\n\n  addTeacher(teacher: Partial<Teacher>): Observable<void> {\n    const ref = doc(this.teacherCollection, teacher.uid);\n    return from(getDoc(ref)).pipe(\n      switchMap(doc => {\n        teacher.updated_on = Timestamp.now();\n        teacher.start_date = Timestamp.now();\n        if (doc.exists()) {\n          return from(updateDoc(ref, teacher))\n        }\n        teacher.created_on = Timestamp.now();\n        return from(setDoc(ref, teacher))\n      }),\n      switchMap(() => this.userApiService.updateUser({\n        uid: teacher.uid,\n        is_teacher: true,\n      })),\n    )\n  }\n\n  removeTeacher(teacher: Partial<Teacher>): Observable<void> {\n    const ref = doc(this.teacherCollection, teacher.uid);\n    teacher.updated_on = Timestamp.now();\n    teacher.end_date = Timestamp.now();\n    return from(updateDoc(ref, {\n      uid: teacher.uid,\n      is_active: false,\n      updated_on: teacher.updated_on,\n      end_date: teacher.end_date,\n    })).pipe(\n      switchMap(() => this.userApiService.updateUser({\n        uid: teacher.uid,\n        is_teacher: false,\n      })),\n    );\n  }\n}\n","import { Injectable, inject } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { ProfileDTO } from 'src/app/backend/model/profile';\nimport { Teacher, TeacherDTO } from 'src/app/backend/model/teacher';\nimport { TeacherApiService } from 'src/app/backend/services/teacher-api.service';\nimport { UserApiService } from 'src/app/backend/services/user-api.service';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class TeacherService {\n  private teacherApiService = inject(TeacherApiService);\n  private userApiService = inject(UserApiService);\n\n  getList(): Observable<TeacherDTO[]> {\n    return this.teacherApiService.getTeachers();\n  }\n\n  getUsers(): Observable<ProfileDTO[]> {\n    return this.userApiService.getUsersNotTeachers();\n  }\n\n  addTeacher(teacher: Partial<Teacher>): Observable<void> {\n    return this.teacherApiService.addTeacher(teacher);\n  }\n\n  removeTeacher(teacher: Partial<Teacher>): Observable<void> {\n    return this.teacherApiService.removeTeacher(teacher);\n  }\n}\n"],"x_google_ignoreList":[]}